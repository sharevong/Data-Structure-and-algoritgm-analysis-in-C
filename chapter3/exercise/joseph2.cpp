/********************************************************
* 3.10 josephus问题：
* N个人从1到N编号，围成一个圆圈，从1号开始传递土豆，
* M次传递后拿到土豆的人离开，下一个人重新开始继续游戏，
* 最后剩下的人获胜
* 如果M=0 N=5 则5号获胜
* 如果M=1 N=5 则3号获胜
*
*******************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

// 算法2：
/* 假设M=1 N=5, 人员编号为 0 1 2 3 4，实际为这些编号加1，假设最后留下的是x(N)
*  第一轮1号离开，剩下的人员为 2 3 4 0，
*  将他们重新按顺序编号则变为  0 1 2 3，可以发现2=(0+2)%5 3=(1+2)%5 4=(2+2)%5 0=(3+2)%5
*  可以发现两轮之间的编号规律为 x(N) = ( x(N-1) + M+1 ) % N i为一轮中人的总数
*  M次传递相当于M+1次计数(报数)
* （因为每一轮都经过了M+1次计数且重新从0分配编号，上一轮的人员编号应等于新一轮的编号加上M，由于围成一圈，需要对总人数取余）
*  显然当只有一个人时，最后获胜的人也是第一个人，即x(1)=0
*  使用递推关系可以找到N个人时的获胜者 
*/

/* 使用报数场景进行分析：
当有n个人的时候，他们的编号依次是0、1、2、3、4、………、n-1。假设最后编号为x(n)的人会留下来。
因为数到m的那个人会出列，那么此轮中编号为(m-1)%n的人会出列，编号为(m+0)%n的人将做为下一轮编号为0的人，此轮编号为(m+i)%n的人将做为下一轮编号为i的人
因此当有n-1个人的时候，编号为i的人对应着上一轮编号为(m+i)%n的人。假设此轮编号为x(n-1)的人最终会留下来。
因为编号为x(n-1)的人肯定对应着上一轮的x(n)，所以有x(n)=(m+x(n-1))%n
有了这个递推公式，那我们就可以一直递推到x(2)=(m+x(1))%2，而x(1)=0。
所以我们可以这么来写这个函数:
j = 0
for i 从 2 到 n：
j = （m+j）%i
最终第j个人会留下来(如果从1开始编号就是第j+1个人最终会留下来)。
*/

int main( int argc, char** argv )
{
    int res = 0 ;
    int M = 1 ;  // M次传递相当于M+1次报数（从1开始报数）
    int N = 5 ;
    for( int i = 2;i <=N;i++ )
    {
        res = ( res + M + 1 ) % i ;
    }  
    printf( "the last is %d\n", res+1 ) ;  // 实际结果应加1，因为实际编号从1开始而不是从0开始      
}
